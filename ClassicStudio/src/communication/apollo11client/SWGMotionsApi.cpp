/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.1
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGMotionsApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGMotionsApi::SWGMotionsApi() {}

SWGMotionsApi::~SWGMotionsApi() {}

SWGMotionsApi::SWGMotionsApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGMotionsApi::deleteMotionsGait(SWGUserTime& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions/gait");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::deleteMotionsGaitCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::deleteMotionsGaitCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteMotionsGaitSignal(output);
    } else {
        emit deleteMotionsGaitSignalE(output, error_type, error_str);
        emit deleteMotionsGaitSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::deleteMotionsMusic(SWGName& body) {
    QString fullPath;
    fullPath.append(this->host)
            .append(this->basePath)
            .append("/motions");

    qDebug() << "fullPath====" << fullPath;

    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");
    
    QString output = QString("{\"motion\": {\"name\": \"%1\"},\"operation\": \"delete\"}").arg(*body.getName());
    input.request_body.append(output);

    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::deleteMotionsMusicCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::deleteMotionsMusicCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteMotionsMusicSignal(output);
    } else {
        emit deleteMotionsMusicSignalE(output, error_type, error_str);
        emit deleteMotionsMusicSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::getMotions() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::getMotionsCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::getMotionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGMotionsStatusResponse* output = static_cast<SWGMotionsStatusResponse*>(create(json, QString("SWGMotionsStatusResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGMotionsStatusResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMotionsSignal(output);
    } else {
        emit getMotionsSignalE(output, error_type, error_str);
        emit getMotionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::getMotionsGait() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions/gait");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::getMotionsGaitCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::getMotionsGaitCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMotionsGaitSignal(output);
    } else {
        emit getMotionsGaitSignalE(output, error_type, error_str);
        emit getMotionsGaitSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::getMotionsList() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions/list");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::getMotionsListCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::getMotionsListCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGMotionsListResponse* output = static_cast<SWGMotionsListResponse*>(create(json, QString("SWGMotionsListResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGMotionsListResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMotionsListSignal(output);
    } else {
        emit getMotionsListSignalE(output, error_type, error_str);
        emit getMotionsListSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::postMotions(SWGHttpRequestInputFileElement* file) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");

    if (file != nullptr) {
        input.add_file("file", (*file).local_filename, (*file).request_filename, (*file).mime_type);
    }




    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::postMotionsCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::postMotionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postMotionsSignal(output);
    } else {
        emit postMotionsSignalE(output, error_type, error_str);
        emit postMotionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::putMotions(SWGMotionsOperation& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::putMotionsCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::putMotionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGRuntimeResponse* output = static_cast<SWGRuntimeResponse*>(create(json, QString("SWGRuntimeResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGRuntimeResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putMotionsSignal(output);
    } else {
        emit putMotionsSignalE(output, error_type, error_str);
        emit putMotionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMotionsApi::putMotionsGait(SWGMotionsGaitOperation& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/motions/gait");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMotionsApi::putMotionsGaitCallback);

    worker->execute(&input);
}

void
SWGMotionsApi::putMotionsGaitCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putMotionsGaitSignal(output);
    } else {
        emit putMotionsGaitSignalE(output, error_type, error_str);
        emit putMotionsGaitSignalEFull(worker, error_type, error_str);
    }
}


}
