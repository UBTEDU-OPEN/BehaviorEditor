/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.1
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGSubscriptionsApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGSubscriptionsApi::SWGSubscriptionsApi() {}

SWGSubscriptionsApi::~SWGSubscriptionsApi() {}

SWGSubscriptionsApi::SWGSubscriptionsApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGSubscriptionsApi::deleteMotionsGaitSubscription(SWGSubscriptionsMotionsGaitDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/motions/gait");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteMotionsGaitSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteMotionsGaitSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteMotionsGaitSubscriptionSignal(output);
    } else {
        emit deleteMotionsGaitSubscriptionSignalE(output, error_type, error_str);
        emit deleteMotionsGaitSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteMotionsSubscription(SWGSubscriptionsMotionsDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/motions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteMotionsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteMotionsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteMotionsSubscriptionSignal(output);
    } else {
        emit deleteMotionsSubscriptionSignalE(output, error_type, error_str);
        emit deleteMotionsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteSensorsSubscription(SWGSubscriptionsSensorsDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/sensors");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteSensorsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteSensorsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteSensorsSubscriptionSignal(output);
    } else {
        emit deleteSensorsSubscriptionSignalE(output, error_type, error_str);
        emit deleteSensorsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteVisionsSubscription(SWGSubscriptionsVisionsDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/visions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteVisionsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteVisionsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVisionsSubscriptionSignal(output);
    } else {
        emit deleteVisionsSubscriptionSignalE(output, error_type, error_str);
        emit deleteVisionsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteVoiceAsrSubscription(SWGSubscriptionsAsrVoiceDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/asr");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteVoiceAsrSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteVoiceAsrSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVoiceAsrSubscriptionSignal(output);
    } else {
        emit deleteVoiceAsrSubscriptionSignalE(output, error_type, error_str);
        emit deleteVoiceAsrSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteVoiceIatSubscription(SWGSubscriptionsIatVoiceDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/iat");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteVoiceIatSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteVoiceIatSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVoiceIatSubscriptionSignal(output);
    } else {
        emit deleteVoiceIatSubscriptionSignalE(output, error_type, error_str);
        emit deleteVoiceIatSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::deleteVoiceTtsSubscription(SWGSubscriptionsTtsVoiceDelete& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/tts");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::deleteVoiceTtsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::deleteVoiceTtsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVoiceTtsSubscriptionSignal(output);
    } else {
        emit deleteVoiceTtsSubscriptionSignalE(output, error_type, error_str);
        emit deleteVoiceTtsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postMotionsGaitSubscription(SWGSubscriptionsMotionsGait& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/motions/gait");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postMotionsGaitSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postMotionsGaitSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postMotionsGaitSubscriptionSignal(output);
    } else {
        emit postMotionsGaitSubscriptionSignalE(output, error_type, error_str);
        emit postMotionsGaitSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postMotionsSubscription(SWGSubscriptionsMotions& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/motions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postMotionsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postMotionsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postMotionsSubscriptionSignal(output);
    } else {
        emit postMotionsSubscriptionSignalE(output, error_type, error_str);
        emit postMotionsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postSensorsSubscription(SWGSubscriptionsSensors& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/sensors");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postSensorsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postSensorsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postSensorsSubscriptionSignal(output);
    } else {
        emit postSensorsSubscriptionSignalE(output, error_type, error_str);
        emit postSensorsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postVisionsSubscription(SWGSubscriptionsVisions& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/visions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postVisionsSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postVisionsSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVisionsSubscriptionSignal(output);
    } else {
        emit postVisionsSubscriptionSignalE(output, error_type, error_str);
        emit postVisionsSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postVoiceAsrSubscriptions(SWGSubscriptionsAsrVoice& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/asr");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postVoiceAsrSubscriptionsCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postVoiceAsrSubscriptionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVoiceAsrSubscriptionsSignal(output);
    } else {
        emit postVoiceAsrSubscriptionsSignalE(output, error_type, error_str);
        emit postVoiceAsrSubscriptionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postVoiceIatSubscription(SWGSubscriptionsIatVoice& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/iat");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postVoiceIatSubscriptionCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postVoiceIatSubscriptionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVoiceIatSubscriptionSignal(output);
    } else {
        emit postVoiceIatSubscriptionSignalE(output, error_type, error_str);
        emit postVoiceIatSubscriptionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGSubscriptionsApi::postVoiceTtsSubscriptions(SWGSubscriptionsTtsVoice& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/subscriptions/voice/tts");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGSubscriptionsApi::postVoiceTtsSubscriptionsCallback);

    worker->execute(&input);
}

void
SWGSubscriptionsApi::postVoiceTtsSubscriptionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVoiceTtsSubscriptionsSignal(output);
    } else {
        emit postVoiceTtsSubscriptionsSignalE(output, error_type, error_str);
        emit postVoiceTtsSubscriptionsSignalEFull(worker, error_type, error_str);
    }
}


}
