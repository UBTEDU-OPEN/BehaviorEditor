/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.0
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGVisionsApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGVisionsApi::SWGVisionsApi() {}

SWGVisionsApi::~SWGVisionsApi() {}

SWGVisionsApi::SWGVisionsApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGVisionsApi::deleteVisionPhoto(SWGName& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photos");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::deleteVisionPhotoCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::deleteVisionPhotoCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVisionPhotoSignal(output);
    } else {
        emit deleteVisionPhotoSignalE(output, error_type, error_str);
        emit deleteVisionPhotoSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::deleteVisionPhotoSamples(SWGName& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photosamples");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::deleteVisionPhotoSamplesCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::deleteVisionPhotoSamplesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVisionPhotoSamplesSignal(output);
    } else {
        emit deleteVisionPhotoSamplesSignalE(output, error_type, error_str);
        emit deleteVisionPhotoSamplesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::deleteVisionsStreams() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/streams");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::deleteVisionsStreamsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::deleteVisionsStreamsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVisionsStreamsSignal(output);
    } else {
        emit deleteVisionsStreamsSignalE(output, error_type, error_str);
        emit deleteVisionsStreamsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::deleteVisionsTags(SWGVisionsDeleteTags& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/tags");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::deleteVisionsTagsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::deleteVisionsTagsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteVisionsTagsSignal(output);
    } else {
        emit deleteVisionsTagsSignalE(output, error_type, error_str);
        emit deleteVisionsTagsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::getPhotoSamples() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photosamples");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::getPhotoSamplesCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::getPhotoSamplesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsPhotoListResponse* output = static_cast<SWGVisionsPhotoListResponse*>(create(json, QString("SWGVisionsPhotoListResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsPhotoListResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getPhotoSamplesSignal(output);
    } else {
        emit getPhotoSamplesSignalE(output, error_type, error_str);
        emit getPhotoSamplesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::getVision(QString* option, QString* type) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("option"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(option)));

    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("type"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(type)));


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::getVisionCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::getVisionCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsGetResponse* output = static_cast<SWGVisionsGetResponse*>(create(json, QString("SWGVisionsGetResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsGetResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getVisionSignal(output);
    } else {
        emit getVisionSignalE(output, error_type, error_str);
        emit getVisionSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::getVisionsPhotos(QString* body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photos");


    if (fullPath.indexOf("?") > 0)
      fullPath.append("&");
    else
      fullPath.append("?");
    fullPath.append(QUrl::toPercentEncoding("body"))
        .append("=")
        .append(QUrl::toPercentEncoding(stringValue(body)));


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::getVisionsPhotosCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::getVisionsPhotosCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getVisionsPhotosSignal();
    } else {
        emit getVisionsPhotosSignalE(error_type, error_str);
        emit getVisionsPhotosSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::getVisionsPhotosLists() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photos/list");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::getVisionsPhotosListsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::getVisionsPhotosListsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsPhotoListResponse* output = static_cast<SWGVisionsPhotoListResponse*>(create(json, QString("SWGVisionsPhotoListResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsPhotoListResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getVisionsPhotosListsSignal(output);
    } else {
        emit getVisionsPhotosListsSignalE(output, error_type, error_str);
        emit getVisionsPhotosListsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::getVisionsTags() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/tags");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::getVisionsTagsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::getVisionsTagsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsTagsResponse* output = static_cast<SWGVisionsTagsResponse*>(create(json, QString("SWGVisionsTagsResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsTagsResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getVisionsTagsSignal(output);
    } else {
        emit getVisionsTagsSignalE(output, error_type, error_str);
        emit getVisionsTagsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::postVisionPhoto(SWGVisionsPhoto& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photos");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::postVisionPhotoCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::postVisionPhotoCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsPhotoResponse* output = static_cast<SWGVisionsPhotoResponse*>(create(json, QString("SWGVisionsPhotoResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsPhotoResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVisionPhotoSignal(output);
    } else {
        emit postVisionPhotoSignalE(output, error_type, error_str);
        emit postVisionPhotoSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::postVisionsPhotoSamples(SWGHttpRequestInputFileElement* file) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/photosamples");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");

    if (file != nullptr) {
        input.add_file("file", (*file).local_filename, (*file).request_filename, (*file).mime_type);
    }




    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::postVisionsPhotoSamplesCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::postVisionsPhotoSamplesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVisionsPhotoSamplesSignal(output);
    } else {
        emit postVisionsPhotoSamplesSignalE(output, error_type, error_str);
        emit postVisionsPhotoSamplesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::postVisionsStreams(SWGVisionsStream& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/streams");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::postVisionsStreamsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::postVisionsStreamsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postVisionsStreamsSignal(output);
    } else {
        emit postVisionsStreamsSignalE(output, error_type, error_str);
        emit postVisionsStreamsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::putVisions(SWGVisionsTask& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::putVisionsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::putVisionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGVisionsPutResponse* output = static_cast<SWGVisionsPutResponse*>(create(json, QString("SWGVisionsPutResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGVisionsPutResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putVisionsSignal(output);
    } else {
        emit putVisionsSignalE(output, error_type, error_str);
        emit putVisionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGVisionsApi::putVisionsTags(SWGVisionsPutTags& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/visions/tags");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGVisionsApi::putVisionsTagsCallback);

    worker->execute(&input);
}

void
SWGVisionsApi::putVisionsTagsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putVisionsTagsSignal(output);
    } else {
        emit putVisionsTagsSignalE(output, error_type, error_str);
        emit putVisionsTagsSignalEFull(worker, error_type, error_str);
    }
}


}
