/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.0
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGServosApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGServosApi::SWGServosApi() {}

SWGServosApi::~SWGServosApi() {}

SWGServosApi::SWGServosApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGServosApi::getHandsDistance(QList<QString*>* names) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/hands");




    if (names->size() > 0) {
      if (QString("multi").indexOf("multi") == 0) {
        foreach(QString* t, *names) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("names=").append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::getHandsDistanceCallback);

    worker->execute(&input);
}

void
SWGServosApi::getHandsDistanceCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosHandsResponse* output = static_cast<SWGServosHandsResponse*>(create(json, QString("SWGServosHandsResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosHandsResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getHandsDistanceSignal(output);
    } else {
        emit getHandsDistanceSignalE(output, error_type, error_str);
        emit getHandsDistanceSignalEFull(worker, error_type, error_str);
    }
}

void
SWGServosApi::getServosAngles(QList<QString*>* names) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/angles");




    if (names->size() > 0) {
      if (QString("multi").indexOf("multi") == 0) {
        foreach(QString* t, *names) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("names=").append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::getServosAnglesCallback);

    worker->execute(&input);
}

void
SWGServosApi::getServosAnglesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosAnglesResponse* output = static_cast<SWGServosAnglesResponse*>(create(json, QString("SWGServosAnglesResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosAnglesResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getServosAnglesSignal(output);
    } else {
        emit getServosAnglesSignalE(output, error_type, error_str);
        emit getServosAnglesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGServosApi::getServosMode(QList<QString*>* names) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/mode");




    if (names->size() > 0) {
      if (QString("multi").indexOf("multi") == 0) {
        foreach(QString* t, *names) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("names=").append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("names=");
        qint32 count = 0;
        foreach(QString* t, *names) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::getServosModeCallback);

    worker->execute(&input);
}

void
SWGServosApi::getServosModeCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosModeResponse* output = static_cast<SWGServosModeResponse*>(create(json, QString("SWGServosModeResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosModeResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getServosModeSignal(output);
    } else {
        emit getServosModeSignalE(output, error_type, error_str);
        emit getServosModeSignalEFull(worker, error_type, error_str);
    }
}

void
SWGServosApi::putHandsDistance(SWGServosHandsRequest& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/hands");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::putHandsDistanceCallback);

    worker->execute(&input);
}

void
SWGServosApi::putHandsDistanceCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosHandsResponse* output = static_cast<SWGServosHandsResponse*>(create(json, QString("SWGServosHandsResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosHandsResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putHandsDistanceSignal(output);
    } else {
        emit putHandsDistanceSignalE(output, error_type, error_str);
        emit putHandsDistanceSignalEFull(worker, error_type, error_str);
    }
}

void
SWGServosApi::putServosAngles(SWGServosAnglesRequest& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/angles");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::putServosAnglesCallback);

    worker->execute(&input);
}

void
SWGServosApi::putServosAnglesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosResultResponse* output = static_cast<SWGServosResultResponse*>(create(json, QString("SWGServosResultResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosResultResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putServosAnglesSignal(output);
    } else {
        emit putServosAnglesSignalE(output, error_type, error_str);
        emit putServosAnglesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGServosApi::putServosMode(SWGServosModeRequest& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/servos/mode");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGServosApi::putServosModeCallback);

    worker->execute(&input);
}

void
SWGServosApi::putServosModeCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGServosResultResponse* output = static_cast<SWGServosResultResponse*>(create(json, QString("SWGServosResultResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGServosResultResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putServosModeSignal(output);
    } else {
        emit putServosModeSignalE(output, error_type, error_str);
        emit putServosModeSignalEFull(worker, error_type, error_str);
    }
}


}
