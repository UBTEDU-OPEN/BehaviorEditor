/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.0
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGDevicesApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGDevicesApi::SWGDevicesApi() {}

SWGDevicesApi::~SWGDevicesApi() {}

SWGDevicesApi::SWGDevicesApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGDevicesApi::getDevicesBattery() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/battery");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesBatteryCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesBatteryCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesBatteryResponse* output = static_cast<SWGDevicesBatteryResponse*>(create(json, QString("SWGDevicesBatteryResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesBatteryResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesBatterySignal(output);
    } else {
        emit getDevicesBatterySignalE(output, error_type, error_str);
        emit getDevicesBatterySignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::getDevicesFallManagement() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/fall_management");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesFallManagementCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesFallManagementCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesFallManagementResponse* output = static_cast<SWGDevicesFallManagementResponse*>(create(json, QString("SWGDevicesFallManagementResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesFallManagementResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesFallManagementSignal(output);
    } else {
        emit getDevicesFallManagementSignalE(output, error_type, error_str);
        emit getDevicesFallManagementSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::getDevicesLanguages() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/languages");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesLanguagesCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesLanguagesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesLanguageResponse* output = static_cast<SWGDevicesLanguageResponse*>(create(json, QString("SWGDevicesLanguageResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesLanguageResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesLanguagesSignal(output);
    } else {
        emit getDevicesLanguagesSignalE(output, error_type, error_str);
        emit getDevicesLanguagesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::getDevicesLed() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/led");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesLedCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesLedCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesLEDResponse* output = static_cast<SWGDevicesLEDResponse*>(create(json, QString("SWGDevicesLEDResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesLEDResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesLedSignal(output);
    } else {
        emit getDevicesLedSignalE(output, error_type, error_str);
        emit getDevicesLedSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::getDevicesVersions(QList<QString*>* type) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/versions");




    if (type->size() > 0) {
      if (QString("multi").indexOf("multi") == 0) {
        foreach(QString* t, *type) {
          if (fullPath.indexOf("?") > 0)
            fullPath.append("&");
          else
            fullPath.append("?");
          fullPath.append("type=").append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("ssv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("type=");
        qint32 count = 0;
        foreach(QString* t, *type) {
          if (count > 0) {
            fullPath.append(" ");
          }
          fullPath.append(stringValue(t));
        }
      }
      else if (QString("multi").indexOf("tsv") == 0) {
        if (fullPath.indexOf("?") > 0)
          fullPath.append("&");
        else
          fullPath.append("?");
        fullPath.append("type=");
        qint32 count = 0;
        foreach(QString* t, *type) {
          if (count > 0) {
            fullPath.append("\t");
          }
          fullPath.append(stringValue(t));
        }
      }
    }


    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesVersionsCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesVersionsCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesVersionsResponse* output = static_cast<SWGDevicesVersionsResponse*>(create(json, QString("SWGDevicesVersionsResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesVersionsResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesVersionsSignal(output);
    } else {
        emit getDevicesVersionsSignalE(output, error_type, error_str);
        emit getDevicesVersionsSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::getDevicesVolume() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/volume");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::getDevicesVolumeCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::getDevicesVolumeCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGDevicesVolumeResponse* output = static_cast<SWGDevicesVolumeResponse*>(create(json, QString("SWGDevicesVolumeResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGDevicesVolumeResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getDevicesVolumeSignal(output);
    } else {
        emit getDevicesVolumeSignalE(output, error_type, error_str);
        emit getDevicesVolumeSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::putDevicesFallManagement(SWGDevicesFallManagement& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/fall_management");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::putDevicesFallManagementCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::putDevicesFallManagementCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putDevicesFallManagementSignal(output);
    } else {
        emit putDevicesFallManagementSignalE(output, error_type, error_str);
        emit putDevicesFallManagementSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::putDevicesLanguages(SWGDevicesLanguage& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/languages");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::putDevicesLanguagesCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::putDevicesLanguagesCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putDevicesLanguagesSignal(output);
    } else {
        emit putDevicesLanguagesSignalE(output, error_type, error_str);
        emit putDevicesLanguagesSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::putDevicesLed(SWGDevicesLED& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/led");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::putDevicesLedCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::putDevicesLedCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putDevicesLedSignal(output);
    } else {
        emit putDevicesLedSignalE(output, error_type, error_str);
        emit putDevicesLedSignalEFull(worker, error_type, error_str);
    }
}

void
SWGDevicesApi::putDevicesVolume(SWGDevicesVolume& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/devices/volume");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGDevicesApi::putDevicesVolumeCallback);

    worker->execute(&input);
}

void
SWGDevicesApi::putDevicesVolumeCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putDevicesVolumeSignal(output);
    } else {
        emit putDevicesVolumeSignalE(output, error_type, error_str);
        emit putDevicesVolumeSignalEFull(worker, error_type, error_str);
    }
}


}
