/**
 * Yanshee RESTful API
 *  ## 概述 Yanshee RESTful APIs是由使用[swagger-codegen](https://github.com/swagger-api/swagger-codegen)基于 [OpenAPI-Spec](https://github.com/swagger-api/swagger-core/wiki)的工程。 所有的API由Flask的[Connexion](https://github.com/zalando/connexion)来解释。 Yanshee-ROS中的apollo提供所有的RESTful APIs服务。 同时Yanshee RESTful APIs提供英文和中文两个版本： - [英文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_en/1.0.0) - [中文版本](https://app.swaggerhub.com/apis-docs/UBTEDU/apollo_cn/1.0.0)  ## 依赖 Python 2.7 or 3.4+  
 *
 * OpenAPI spec version: 1.0.0
 * Contact: swenggroup@ubtrobot.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#include "SWGMediaApi.h"
#include "SWGHelpers.h"
#include "SWGModelFactory.h"
#include "SWGQObjectWrapper.h"

#include <QJsonArray>
#include <QJsonDocument>

namespace Swagger {

SWGMediaApi::SWGMediaApi() {}

SWGMediaApi::~SWGMediaApi() {}

SWGMediaApi::SWGMediaApi(QString host, QString basePath) {
    this->host = host;
    this->basePath = basePath;
}

void
SWGMediaApi::deleteMediaMusic(SWGName& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/media/music");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "DELETE");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMediaApi::deleteMediaMusicCallback);

    worker->execute(&input);
}

void
SWGMediaApi::deleteMediaMusicCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit deleteMediaMusicSignal(output);
    } else {
        emit deleteMediaMusicSignalE(output, error_type, error_str);
        emit deleteMediaMusicSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMediaApi::getMediaMusic() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/media/music");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMediaApi::getMediaMusicCallback);

    worker->execute(&input);
}

void
SWGMediaApi::getMediaMusicCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGMediaMusicStatusResponse* output = static_cast<SWGMediaMusicStatusResponse*>(create(json, QString("SWGMediaMusicStatusResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGMediaMusicStatusResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMediaMusicSignal(output);
    } else {
        emit getMediaMusicSignalE(output, error_type, error_str);
        emit getMediaMusicSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMediaApi::getMediaMusicList() {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/media/music/list");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "GET");





    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMediaApi::getMediaMusicListCallback);

    worker->execute(&input);
}

void
SWGMediaApi::getMediaMusicListCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGMediaMusicListResponse* output = static_cast<SWGMediaMusicListResponse*>(create(json, QString("SWGMediaMusicListResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGMediaMusicListResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getMediaMusicListSignal(output);
    } else {
        emit getMediaMusicListSignalE(output, error_type, error_str);
        emit getMediaMusicListSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMediaApi::postMediaMusic(SWGHttpRequestInputFileElement* file) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/media/music");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "POST");

    if (file != nullptr) {
        input.add_file("file", (*file).local_filename, (*file).request_filename, (*file).mime_type);
    }




    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMediaApi::postMediaMusicCallback);

    worker->execute(&input);
}

void
SWGMediaApi::postMediaMusicCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGCommonResponse* output = static_cast<SWGCommonResponse*>(create(json, QString("SWGCommonResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGCommonResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit postMediaMusicSignal(output);
    } else {
        emit postMediaMusicSignalE(output, error_type, error_str);
        emit postMediaMusicSignalEFull(worker, error_type, error_str);
    }
}

void
SWGMediaApi::putMediaMusic(SWGMediaMusicOperation& body) {
    QString fullPath;
    fullPath.append(this->host).append(this->basePath).append("/media/music");



    SWGHttpRequestWorker *worker = new SWGHttpRequestWorker();
    SWGHttpRequestInput input(fullPath, "PUT");


    
    QString output = body.asJson();
    input.request_body.append(output);
    


    foreach(QString key, this->defaultHeaders.keys()) {
        input.headers.insert(key, this->defaultHeaders.value(key));
    }

    connect(worker,
            &SWGHttpRequestWorker::on_execution_finished,
            this,
            &SWGMediaApi::putMediaMusicCallback);

    worker->execute(&input);
}

void
SWGMediaApi::putMediaMusicCallback(SWGHttpRequestWorker * worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    }
    else {
        msg = "Error: " + worker->error_str;
    }

    QString json(worker->response);
    SWGRuntimeResponse* output = static_cast<SWGRuntimeResponse*>(create(json, QString("SWGRuntimeResponse")));
    auto wrapper = new SWGQObjectWrapper<SWGRuntimeResponse*> (output);
    wrapper->deleteLater();
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit putMediaMusicSignal(output);
    } else {
        emit putMediaMusicSignalE(output, error_type, error_str);
        emit putMediaMusicSignalEFull(worker, error_type, error_str);
    }
}


}
